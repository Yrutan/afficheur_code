<!DOCTYPE html><head><style>.bleu{color:blue};</style><title>Afficheur de code</title></head><pre>/*************************************************************************<br><br>	Fait par Antoine Latendresse, Léa Kelly et Simon Roy<br><br>*************************************************************************/<br>#<span  class='bleu'  >include</span> &ltstring&gt<br>#<span  class='bleu'  >include</span> &ltvector&gt<br>#<span  class='bleu'  >include</span> &ltmap&gt<br>#<span  class='bleu'  >include</span> &ltalgorithm&gt<br>#<span  class='bleu'  >include</span> &ltregex&gt<br>#<span  class='bleu'  >include</span> &ltfstream&gt<br>#<span  class='bleu'  >include</span> &ltiostream&gt<br>#<span  class='bleu'  >include</span> &ltchrono&gt<br>#<span  class='bleu'  >include</span> &ltthread&gt<br>#<span  class='bleu'  >include</span> "keywords.cpp"<br>#<span  class='bleu'  >include</span> "initialisation.cpp"<br>#<span  class='bleu'  >include</span> "parallele.cpp"<br><span  class='bleu'  >using</span> <span  class='bleu'  >namespace</span> std;<br><span  class='bleu'  >using</span> <span  class='bleu'  >namespace</span> std::chrono;<br><br><span  class='bleu'  >const</span> string OPTION_COULEUR_CODE = "couleur";<br><span  class='bleu'  >const</span> string OPTION_STATISTIQUE = "stats";<br><span  class='bleu'  >const</span> string REGEX = "[a-zA-Z0-9_]+";<br><span  class='bleu'  >const</span> <span  class='bleu'  >int</span> NBFICHIERS = 10;<br><br><span  class='bleu'  >const</span> string ESPERLUETTE = "&ampamp"; // &amp<br><span  class='bleu'  >const</span> string PLUS_PETIT = "&amplt"; // &lt<br><span  class='bleu'  >const</span> string PLUS_GRAND = "&ampgt"; // &gt<br><br>map&ltstring, string&gt SPECIAL_CHAR{ <br>	{ "&amp" , ESPERLUETTE },<br>	{ "&lt", PLUS_PETIT },<br>	{ "&gt" , PLUS_GRAND }<br>};<br><br><span  class='bleu'  >const</span> string BALISE_DEBUT = "&ltspan&gt";<br><span  class='bleu'  >const</span> string BALISE_FIN = "&lt/span&gt";<br><br><span  class='bleu'  >const</span> string CSS_BLEU = " class='bleu' ";<br><span  class='bleu'  >const</span> string OUVERTURE_SPAN = "&ltspan ";<br><span  class='bleu'  >const</span> string FERMETURE_BALISE = " &gt";<br><br><span  class='bleu'  >bool</span> compare(<span  class='bleu'  >const</span> pair&ltstring, int&gt&ampi, <span  class='bleu'  >const</span> pair&ltstring, int&gt&ampj)<br>{<br>	// si ils n'ont pas la même valeur (même nombre) alors on compare lequel en a le plus<br>	// sinon on les compare de manière lexicographique<br>	<span  class='bleu'  >return</span> i.second != j.second ? i.second &gt j.second : std::lexicographical_compare(i.first.begin(), i.first.end(), j.first.begin(), j.first.end());<br>}<br><br><span  class='bleu'  >void</span> generer_stats(<span  class='bleu'  >const</span> string nom_fichier)<br>{<br>	string pattern{ "[a-zA-Z0-9]+" };<br>	regex expression{ pattern };<br><br>	map&ltstring, int&gt donnees;<br>	ifstream in{ nom_fichier };<br><br>	<span  class='bleu'  >for</span> (string s; in &gt&gt s;)<br>		if(regex_match(s, expression))<br>			donnees[s]++;<br><br>	vector&ltpair&ltstring, int&gt&gt stats;<br><br>	<span  class='bleu'  >for</span> (<span  class='bleu'  >auto</span> &amp p : donnees)<br>		stats.push_back(make_pair(p.first, p.second));<br><br>	sort(stats.begin(), stats.end(), compare);<br><br>	ofstream output(nom_fichier +"_stats.txt");<br><br>	<span  class='bleu'  >if</span> (output.is_open())<br>		<span  class='bleu'  >for</span> (<span  class='bleu'  >auto</span> &amp p : stats)<br>			output &lt&lt p.first &lt&lt " : " &lt&lt p.second &lt&lt endl;<br><br>	// pas de close(), car les flux sont des objets RAII<br>}<br><br>// Fonction utilisée pour vérifier l'existence d'un fichier<br>// Ouvrir le fichier et le convertir en booléen<br><span  class='bleu'  >bool</span> fichier_existe(<span  class='bleu'  >const</span> string &ampnom)<br>{<br>	<span  class='bleu'  >return</span> !!(ifstream{ nom });<br>}<br><br><br><span  class='bleu'  >void</span> remplacer(<span  class='bleu'  >const</span> string &amptoAdd, <span  class='bleu'  >const</span> string &amptoRemove, string &amptoModified)<br>{<br>	<span  class='bleu'  >int</span> index = 0;<br>	<span  class='bleu'  >while</span> ((index = toModified.find(toRemove, index)) != string::npos)<br>	{<br>		toModified.replace(index, toRemove.length(), toAdd);<br>		index += toAdd.length();<br>	}<br>}<br>string keywordWithCSS(<span  class='bleu'  >const</span> string &ampkeyword)<br>{<br>	<span  class='bleu'  >return</span> OUVERTURE_SPAN + CSS_BLEU + FERMETURE_BALISE + keyword + BALISE_FIN;<br>}<br><span  class='bleu'  >void</span> ajouter_css(vector&ltstring&gt &amplignes)<br>{<br>	//<span  class='bleu'  >bool</span> open_tag = false;<br>	<span  class='bleu'  >int</span> index = 0;<br>	<span  class='bleu'  >for</span> (<span  class='bleu'  >const</span> string &ampkeyword : LISTE)<br>	{<br>		<span  class='bleu'  >for</span> (size_t i = 0; i &lt lignes.size(); ++i)<br>		{<br>			// réinitialise l'index à 0 après chaque ligne<br>			index = 0;<br>			<span  class='bleu'  >while</span> ((index = lignes[i].find(keyword + " ", index)) != string::npos)<br>			{<br>				string new_keyword = keywordWithCSS(keyword);<br><br>				lignes[i].replace(index, keyword.length(), new_keyword);<br>				index += new_keyword.length();<br>			}<br>		}<br>	}<br>}<br><br><span  class='bleu'  >void</span> creer_fichier_web(string nom_fichier, vector&ltstring&gttexte, <span  class='bleu'  >const</span> <span  class='bleu'  >bool</span> &ampcouleur = false)<br>{<br>	<span  class='bleu'  >if</span> (!empty(texte))<br>	{<br>		<span  class='bleu'  >for</span> (string &ampligne :texte)<br>		{<br>			remplacer(SPECIAL_CHAR["&amp"], "&amp", ligne);<br>			remplacer(SPECIAL_CHAR["&lt"], "&lt", ligne);<br>			remplacer(SPECIAL_CHAR["&gt"], "&gt", ligne);<br>		}<br>		<span  class='bleu'  >if</span> (couleur)<br>		{<br>			ajouter_css(texte);<br>		}<br>		texte[0] = "&lt!DOCTYPE html&gt&lthead&gt&ltstyle&gt.bleu{color:blue};&lt/style&gt&lttitle&gtAfficheur de code&lt/title&gt&lt/head&gt&ltpre&gt" + texte[0];<br>		texte.back() += "&lt/pre&gt";<br>	}<br>	ofstream ecrire_fichier;<br>	ecrire_fichier.open(nom_fichier + ".html");<br>	<span  class='bleu'  >if</span> (ecrire_fichier.is_open())<br>	{<br>		<span  class='bleu'  >for</span> (<span  class='bleu'  >auto</span> it_texte = begin(texte); it_texte != end(texte); it_texte++)<br>			ecrire_fichier &lt&lt *it_texte &lt&lt "&ltbr&gt";<br>	}<br>	ecrire_fichier.close();<br>}<br><br><br><span  class='bleu'  >void</span> sequentiel(<span  class='bleu'  >const</span> vector&ltstring&gt &ampnoms_fichiers, <span  class='bleu'  >const</span> <span  class='bleu'  >bool</span> couleur = true, <span  class='bleu'  >const</span> <span  class='bleu'  >bool</span> statistique = true)<br>{<br>	ifstream lire_fichier;<br>	vector&ltstring&gt texte_fichier;<br>	string ligne;<br><br>	<span  class='bleu'  >for</span> (<span  class='bleu'  >auto</span> it = begin(noms_fichiers); it != end(noms_fichiers); it++)<br>	{<br>		<span  class='bleu'  >for</span> (<span  class='bleu'  >int</span> i = 0; i &lt NBFICHIERS; ++i)<br>		{<br>			lire_fichier.open(*it);<br>			<span  class='bleu'  >if</span> (lire_fichier.is_open())<br>			{<br>				<span  class='bleu'  >while</span> (getline(lire_fichier, ligne))<br>				{<br>					texte_fichier.push_back(ligne);<br>				}<br>			}<br>			lire_fichier.close();<br><br>			<span  class='bleu'  >if</span> (statistique)<br>				generer_stats(*it);<br><br>			creer_fichier_web(*it, texte_fichier, couleur);<br>         texte_fichier.clear();<br>		}<br><br>	}<br>}<br><br><br><span  class='bleu'  >int</span> main(<span  class='bleu'  >int</span> argc, <span  class='bleu'  >char</span> * argv[])<br>{<br>	/*********************************************<br>	* Zone d'initialisation du programme<br>	*********************************************/ <br><br>	Initialisation init( argc, argv, std::cout);<br>	ofstream output("resultats_temps.txt");<br>	un<span  class='bleu'  >signed</span> <span  class='bleu'  >int</span> nombre_threads = std::thread::hardware_concurrency();<br><br>	// confirmation des paramètres<br>	cout &lt&lt std::boolalpha; // permet d'afficher true/<span  class='bleu'  >false</span> au lieu de 1/0<br>	cout &lt&lt "Language de programmation recherche : " &lt&lt init.language_prog &lt&lt endl;<br>	cout &lt&lt "Afficher la couleur : " &lt&lt init.couleur &lt&lt endl;<br>	cout &lt&lt "Generer le fichier de statistique : " &lt&lt init.statistique &lt&lt endl;<br>	cout &lt&lt "Nombre de fichiers demandes : " &lt&lt init.noms_fichiers.size() &lt&lt endl;<br>	cout &lt&lt "Nombre de fichiers existants : " &lt&lt init.noms_fichiers.size() &lt&lt endl;<br><br>	/*********************************************<br>	* Fin d'initialisation du programme<br>	*********************************************/<br><br><br>	/*********************************************<br>	* Début de la zone du traitement séquentiel<br>	*********************************************/<br>	//cout &lt&lt "Debut du traitement sequentiel" &lt&lt endl;<br>	// begin timer<br><br>	<span  class='bleu'  >auto</span> avant_seq = high_resolution_clock::now();<br>	<br>	sequentiel(init.noms_fichiers, init.couleur, init.statistique);<br><br>	<span  class='bleu'  >auto</span> apres_seq = high_resolution_clock::now();<br><br>	// end time<br>	//cout &lt&lt "Fin du traitement sequentiel" &lt&lt endl;<br><br>	/*********************************************<br>	* Fin de la zone du traitement séquentiel<br>	*********************************************/<br><br>	<span  class='bleu'  >if</span> (output.is_open())<br>		output &lt&lt "Temps pris pour le traitement sequentiel : "<br>			   &lt&lt duration_cast&ltmilliseconds&gt(apres_seq - avant_seq).count() <br>			   &lt&lt " ms" &lt&lt endl;<br><br>	// afficher le temps pris pour le traitement séquentiel<br><br>	/*********************************************<br>	* Début de la zone du traitement en parallèle<br>	*********************************************/<br>	//cout &lt&lt "Debut du traitement en parallele" &lt&lt endl;<br>	// begin timer<br><br>	<span  class='bleu'  >auto</span> avant_para = high_resolution_clock::now();<br><br>	// Appeler la fonction de traitement parallèle<br><br>	<span  class='bleu'  >auto</span> apres_para = high_resolution_clock::now();<br><br>	// end time<br>	//cout &lt&lt "Fin du traitement en parallele" &lt&lt endl;<br>	/*********************************************<br>	* Fin de la zone du traitement en parallèle<br>	*********************************************/<br><br>	<span  class='bleu'  >if</span> (output.is_open())<br>		output &lt&lt "Temps pris pour le traitement en parallele : "<br>		&lt&lt duration_cast&ltmilliseconds&gt(apres_para - avant_para).count()<br>		&lt&lt " ms" &lt&lt endl;<br><br>	cout &lt&lt "Fin du programme" &lt&lt endl;<br>}</pre><br>