/*************************************************************************<br /><br />	Fait par Antoine Latendresse, Léa Kelly et Simon Roy<br /><br />*************************************************************************/<br /><br /><br />#include "CSS.cpp"<br />#include "keywords.cpp"<br />#include "simon.cpp"<br /><br />#include <string><br />#include <vector><br />#include <map><br />#include <algorithm><br />#include<fstream><br />#include <regex><br />#include <iostream><br />using namespace std;<br /><br />const string STYLE_BLEU = "color='#6495ED'"; // #6495ED Cornflowerblue<br />const string BALISE_DEBUT = "<span >";<br />const string BALISE_OUVERTURE = "<span ";<br />const string BALISE_FERMETURE = " >";<br />const string BALISE_FIN = "</span>";<br /><br />const string PLUS_PETIT = "&lt"; // <<br />const string PLUS_GRAND = "&gt"; // ><br />const string ESPERLUETTE = "&amp"; // &<br /><br /><br /><br />const string COULEUR_CODE = "-couleur";<br />const string STATISTIQUE = "-stats";<br />const string REGEX = "[a-zA-Z0-9_]+";<br /><br />// Non utilisé pour l'instant donc pas nécessaire ?<br />// const string DEFAULT_FILE = "default.cpp";<br /><br />void generer_stats(const string nom_fichier)<br />{<br />	string pattern{ "[a-zA-Z_]([a-zA-Z0-9_])*" };<br />	regex expression{ pattern };<br /><br />	map<string, int> donnees;<br />	ifstream in{ nom_fichier };<br /><br />	// Il faut faire une expression régulière pour filtrer ce que l'on met dans données<br />	for (string s; in >> s;)<br />		if(regex_match(s, expression))<br />			donnees[s]++;<br /><br />	ofstream output;<br />	output.open(nom_fichier + "_stats.txt");<br /><br />	if (output.is_open())<br />	{<br />		for (auto & p : donnees)<br />		{<br />			output << p.first << " : " << p.second << endl;<br />		}<br />	}<br /><br />	output.close();<br />}<br /><br />// Fonction utilisée pour vérifier l'existence d'un fichier<br />// Ouvrir le fichier et le convertir en booléen<br />bool fichier_existe(const string &nom)<br />{<br />	return !!(ifstream{ nom });<br />}<br /><br />int main(int argc, char * argv[])<br />{<br />	bool couleur_code = false;<br />	bool fichier_statistique = false;<br /><br />	/*On a pas besoin de les lignes suivantes je me trompe ?<br />	// le premier paramètre est le nom de l'exécutable<br />	string nom_programme = argv[0];*/<br /><br />	vector<string> noms_fichiers;<br />	/* Non-utilisé ?<br />	vector<string> textes_fichiers; */<br /><br />	if (argc > 1)<br />	{<br />		for (int i = 1; i < argc; i++)<br />		{<br />			string arg = argv[i];<br />			if (arg[0] == '-' || arg[0] == '/') // c'est une option<br />			{<br />				if (arg == COULEUR_CODE)<br />				{<br />					couleur_code = true;<br />				}<br />				else if (arg == STATISTIQUE)<br />				{<br />					fichier_statistique = true;<br />				}<br />			}<br />			else // c'est un fichier<br />			{<br />				if (fichier_existe(arg))<br />					noms_fichiers.push_back(arg);<br />				else<br />					cout << "Le fichier " << arg << " n'existe pas !" << endl;<br />			}<br />		}<br />	}<br /><br />	// Code de test pour s'assurer que les options sont prises en compte<br />	cout << "couleur : " << couleur_code << endl;<br />	cout << "statistique : " << fichier_statistique << endl;<br /><br />	ifstream lire_fichier;<br />	ofstream ecrire_fichier;<br />	vector<string> texte_fichier;<br />	string ligne;<br /><br />	for (auto it = begin(noms_fichiers); it != end(noms_fichiers); it++)<br />	{<br />		lire_fichier.open(*it);<br />		if (lire_fichier.is_open())<br />		{<br />			while (getline(lire_fichier, ligne))<br />			{<br />				texte_fichier.push_back(ligne);<br />			}<br />		}<br />		lire_fichier.close();<br /><br />		if (fichier_statistique)<br />			generer_stats(*it);<br /><br />		if (couleur_code)<br />		{<br />			// ajouter le css au texte (à chaque ligne ?)<br />         size_t index = 0;<br />         for each (string keyword in liste)<br />         {<br />            //auto it = begin(texte_fichier); it != end(texte_fichier); ++it<br />            for (int i = 0; i < texte_fichier.size(); i++)<br />            {<br /><br />               index = texte_fichier[i].find(keyword, index);<br /><br />               if (index == string::npos)break;<br />               <br />               string css_start;<br />               string css_end;<br />               texte_fichier[i].replace(index, keyword.length(), css_start + keyword + css_end);<br />            }<br />         }<br />		}<br /><br />		// ../../ ne change rien... cela écrit toujours dans le fichier courant<br />		ecrire_fichier.open(*it + ".html");<br />		if (ecrire_fichier.is_open())<br />		{<br />			for (auto it_lecture = begin(texte_fichier); it_lecture != end(texte_fichier); it_lecture++)<br />				ecrire_fichier << *it_lecture << "<br />";<br />		}<br />		ecrire_fichier.close();<br />	}<br /><br />}<br />